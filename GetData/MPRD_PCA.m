classdef MPRD_PCA < MAKE_PREDRESP_DATA
    % historical data in NXM array
    % first column is realization
    % columns 2:end are the forecasts
    % the predictor variables for realization in row 'row' are the
    % forecasts from n hours ago
    %
    % historical data = 
    %  [ r(1) f(1,2) f(1,3) f(1,4) ...
    %  [ r(2) f(2,3) f(2,4) f(2,5) ...
    %  [ r(3) f(3,4) f(3,5) f(3,6) ...
    % r(i)  = wind realization over time step (i-1) to i
    % f(i,j) = wind forecast created at the start of time step i that 
    %          predicts the wind realization rj
    %
    % response variables at time step (row) i:
    %  r(i+1)-f(i,j)*do_error
    %  where do_error=1 (true) or =0 (false)
    %
    % predictor variable uses PCA to transform f(i,2:1+pca_nhours)
    %  the transformation is precomputed and time independent
    %  if V is the pca_nhoursXpca_nhours eigenvalues matrix with
    %  non-increasing eigenvalues then the unscaled predictor variable is 
    %    pred1 = f(i,2:1+pca_nhours)*V(end-pca_ncomps:end)
    %  the scaled predictor variable is
    %    pred = (pred-minval(end-pca_ncomps:end))*...
    %               (maxval(end-pca_ncomps:end)-minval(end-pca_ncomps:end))
    %  where V, minval, and maxval are loaded in from the .mat file
    %  generated by the function make_PCA()
    properties
        pca_nhours
        pca_ncomps
        do_error
        V
        minval
        maxval
    end
    methods
        function d= get_description(obj)
            d = ['MPRD_PCA_',num2str(obj.pca_nhours),'_',...
                num2str(obj.pca_ncomps),'_',num2str(obj.do_error)];
        end
        function obj = MPRD_PCA(pca_nhours,pca_ncomps,do_error,offset)
            if nargin<3
                do_error = false;
            end
            if nargin<4
                offset = 0;
            end
            obj = obj@MAKE_PREDRESP_DATA(offset);
            obj.pca_nhours = pca_nhours;
            obj.pca_ncomps = pca_ncomps;
            obj.do_error   = do_error;
            D = load('MPRD_PCA_results.mat');
            ind = find(D.pca_nhours_list==pca_nhours);
            data = D.Vcell{ind};
            obj.V = data.V(:,end+1-pca_ncomps:end);
            obj.minval = data.minval(1,end+1-pca_ncomps:end);
            obj.maxval = data.maxval(1,end+1-pca_ncomps:end);
            % these three variables need to be defined from the parent
            % class
            obj.predresp_nts_lead  = pca_nhours;
            obj.predresp_nts_trail = 1;
            obj.pred_nts_lead      = pca_nhours;
        end
        function M = get_number_pred_vars(obj)
            M = obj.pca_ncomps;
        end
        function [zerop,onep] = get_zero_one_percentiles(obj)
            zerop = @(x) zeros(size(x,1),1);
            onep  = @(x)  ones(size(x,1),1);
        end
        function obj = train_fcn(obj,hist_data)
            % nothing to do
        end
        function Xy = make_predresp_fcn(obj,hist_data,row_start,row_end)
            % make the predictor and response variables from the historical
            % data
            % inputs:
            %  - hist_data: NXT matrix of historical wind data
            %               hist_data(:,1) is the wind realization
            %               hist_data(:,2:end) are the wind forecasts
            %               hist_data(ii,jj) predicts hist_data(ii+jj-1,1)
            %               for jj>1
            %  - row_start: positive integer
            %  - row_end  : positive integer
            % returns:
            %  - Xy: (row_end-row_start+1)Xpca_ncomps array
            %        of predictor variables (columns 1:end-1) and response
            %        variable (column end)
            
            % align forecasts
            m = obj.pca_nhours;
            f = hist_data(:,2:1+m);
            f = MPRD_PCA.align_forecasts(f);
            % the first row of f corresponds to row m of hist_data
            rs = row_start+1-m;
            re = row_end  +1-m;
            X = f(rs:re,:)*obj.V; % this gives all PCs
%             X = X(:,end+1-obj.pca_ncomps:end); % only take the first few
            % now scale
%             min1 = ones(size(X,1),1)*obj.minval(1,end+1-obj.pca_ncomps:end);
%             max1 = ones(size(X,1),1)*obj.maxval(1,end+1-obj.pca_ncomps:end);
%             X = (X-min1)./(max1-min1);
            min1 = ones(size(X,1),1)*obj.minval;
            max1 = ones(size(X,1),1)*obj.maxval;
%             X = (X-obj.minval)./(obj.maxval-obj.minval);
            X = (X-min1)./(max1-min1);
            y = hist_data(row_start+1:row_end+1,1);
            Xy = [X,y];
        end
        function [X, haspred] = make_predscen_fcn(obj,...
                hist_data,hist_row,scen_data,scen_row)
            % make the predictor variables given historical data and
            % generated scenarios
            % inputs:
            %  - hist_data: NXT matrix of historical wind data
            %               hist_data(:,1) is the wind realization
            %               hist_Data(:,2:end) are the wind forecasts
            %               hist_data(ii,jj) predicts hist_data(ii+jj-1,1)
            %               for jj>1
            %  - hist_row  : positive integer
            %  - scen_data : nX1XS 3d array
            %                scen(ii,1,s) is the generated wind scenario at
            %                time step ii in scenario s
            %  - scen_row  : positive integer
            % returns:
            %  - X: SXpca_ncomps array
            %       X(s,:) are the predictor variables created as in 
            %       obj.make_predresp when hist_data(1:n,1) is set to
            %       scen(:,1,s)
            %       Because the predictor variables are independent of the
            %       wind realization/scenario X(ii,:)=X(jj,:)
            %  - haspred: boolean, true if all predictor variables could be
            %  created
            X = hist_data(hist_row-obj.pca_nhours+1:hist_row,1:obj.pca_nhours);
            X = obj.align_forecasts(X);
            X = X*obj.V;
            assert(size(X,1)==1)
%             X = X(1,end+1-obj.pca_ncomps:end);
%             min1 = obj.minval(1,end+1-obj.pca_ncomps:end);
%             max1 = obj.maxval(1,end+1-obj.pca_ncomps:end);
%             X = (X-min1)./(max1-min1);                
            X = (X-obj.minval)./(obj.maxval-obj.minval);
            haspred = all(~isnan(X));
            X = ones(size(scen_data,3),1)*X;
        end 
    end
    
    methods (Static)
        function a = align_forecasts(f)
            m = size(f,2);
            a = zeros(size(f,1)+1-m,m);
            for ii=1:m
                a(:,ii) = f(m+1-ii:end+1-ii,ii);
            end
        end
        function make_PCA()
            pca_nhours_list = 2:24;
            DH = DATA_HANDLER();
            % use this data to do PCA -------------------------------------
            [~,f] = DH.get_seq_data_inclusive(datenum(2013,7,31,0,0,0),...
                datenum(2014,8,1,0,0,0));
            % need to align data
            f1 = MPRD_PCA.align_forecasts(f(:,1:max(pca_nhours_list)));
            % use this data to determine min max values -------------------
            [~,f2] = DH.get_seq_data_inclusive(datenum(2013,4,1,0,0,0),...
                datenum(2014,12,31,0,0,0));
            % fill in missing values
            for row=2:size(f2,1)
                if any(isnan(f2(row,:)))
                    f2(row,1:end-1) = f2(row-1,2:end);
                    f2(row,end)     = f2(row-1,end);
                end
            end
            % align data
            f2 = MPRD_PCA.align_forecasts(f2(:,1:max(pca_nhours_list)));
            
            
            Vcell = cell(1,length(pca_nhours_list));
            for ii=1:length(pca_nhours_list)
                pca_nhours1 = pca_nhours_list(ii);
                [V1,D] = eig(nancov(f1(:,1:pca_nhours1)));
                minval1 = min(f2(:,1:pca_nhours1)*V1);
                maxval1 = max(f2(:,1:pca_nhours1)*V1);
                
                % expand the domain a little
                difval1 = maxval1-minval1;
                difval1 = difval1*0.025;
                minval1 = minval1-difval1;
                maxval1 = maxval1+difval1;
                
%                 minval1 = -sqrt(pca_nhours1)*ones(1,pca_nhours1);
%                 maxval1 =  sqrt(pca_nhours1)*ones(1,pca_nhours1);
                
                d = fliplr(diag(D)');
                Vcell{ii} = struct('V',V1,'minval',minval1,'maxval',maxval1,'d',d);
            end
            save('MPRD_PCA_results.mat','Vcell','pca_nhours_list')
        end
    end
end